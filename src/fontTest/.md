async generateBeforeAfterThumbnailFontTest(photoId: number): Promise<string> {
    let url: string = '';
    const photo = await this.db
      .selectFrom('photos as p')
      .leftJoin('upload_file as uf', 'uf.id', 'p.upload_file_id')
      .where('p.id', '=', photoId)
      .select([
        'p.id as photoId',
        'p.thumbnail_before_after_id as thumbnail_before_after_id',
        'p.selected_design_id as selected_design_id',
        'uf.url as beforeUrl',
      ])
      .executeTakeFirst();
    if (!photo) {
      return '';
    }
    const after = await this.db
      .selectFrom('photo_results as pf')
      .leftJoin('upload_file as uf', 'uf.id', 'pf.result_image_id')
      .where('original_photo_id', '=', photoId)
      .where('hair_design_id', '=', photo.selected_design_id)
      .select(['uf.url as afterUrl'])
      .executeTakeFirst();

    const MAX_THUMBNAIL_RETRY = 2;
    for (let i = 0; i < MAX_THUMBNAIL_RETRY; i++) {
      try {
        const thumbnailBuffer =
          await this.thumbnailService.generateBeforeAfterFontTest(
            photo.beforeUrl,
            after.afterUrl,
          );

        const thumbnailBase64 = `data:image/jpeg;base64,${thumbnailBuffer.toString(
          'base64',
        )}`;
        const thumbnailUpload =
          await this.azureBlobService.uploadFileImageBase64(
            thumbnailBase64,
            false,
            true,
          );

        if (thumbnailUpload) {
          url = thumbnailUpload.url;
          await this.db
            .updateTable('photos')
            .set({ thumbnail_before_after_id: thumbnailUpload.id })
            .where('id', '=', photoId)
            .execute();
          console.log(`[PhotoService] 썸네일 생성 성공 (${i + 1}번째 시도)`);
          break; // 성공 시 루프 탈출
        }
      } catch (error) {
        console.error(
          `[PhotoService] 썸네일 생성 실패 (${i + 1}번째 시도):`,
          error,
        );
        if (i === MAX_THUMBNAIL_RETRY - 1) {
          console.error('[PhotoService] 썸네일 최종 생성 실패');
        }
      }
    }
    return url;
  }

  async generateWorldcupMergedImageFontTest(photoId: number): Promise<string> {
    let url: string = '';
    const photos = await this.db
      .selectFrom('photo_results as pf')
      .leftJoin('upload_file as uf', 'uf.id', 'pf.result_image_id')
      .where('original_photo_id', '=', photoId)
      .select(['uf.url as url'])
      .execute();
    const imageUrls = photos
      .map((r) => r.url)
      .filter(
        (url): url is string => typeof url === 'string' && url.length > 0,
      );
    const MAX_MERGED_IMAGE_RETRY = 2;
    for (let i = 0; i < MAX_MERGED_IMAGE_RETRY; i++) {
      try {
        const mergedImageBuffer =
          await this.thumbnailService.generateMergedWorldcupImageFontTest(
            imageUrls,
          );
        if (!mergedImageBuffer) {
          throw new Error('Thumbnail buffer is empty (generated failed)');
        }
        const mergedImageBase64 = `data:image/jpeg;base64,${mergedImageBuffer.toString(
          'base64',
        )}`;
        const mergedImageUpload =
          await this.azureBlobService.uploadFileImageBase64(
            mergedImageBase64,
            false,
            true,
          );

        if (mergedImageUpload) {
          url = mergedImageUpload.url;
          await this.db
            .updateTable('photos')
            .set({ merged_image_id: mergedImageUpload.id })
            .where('id', '=', photoId)
            .execute();
          //console.log(`[PhotoService] 썸네일 생성 성공 (${i + 1}번째 시도)`);
          break; // 성공 시 루프 탈출
        }
      } catch (error) {
        console.error(
          `[PhotoService] 썸네일 생성 실패 (${i + 1}번째 시도):`,
          error,
        );
        if (i === MAX_MERGED_IMAGE_RETRY - 1) {
          console.error(
            '[PhotoService] Worldcup merged image generation failed',
          );
        }
      }
    }
    return url;
  }
  async generateWorldcupThumbnailImageFontTest(
    photoId: number,
  ): Promise<string> {
    let url: string = '';
    const photos = await this.db
      .selectFrom('photo_results as pf')
      .leftJoin('upload_file as uf', 'uf.id', 'pf.result_image_id')
      .where('original_photo_id', '=', photoId)
      .select(['uf.url as url'])
      .execute();
    const imageUrls = photos
      .map((r) => r.url)
      .filter(
        (url): url is string => typeof url === 'string' && url.length > 0,
      );
    const MAX_THUMBNAIL_RETRY = 2;
    for (let i = 0; i < MAX_THUMBNAIL_RETRY; i++) {
      try {
        const thumbnailBuffer =
          await this.thumbnailService.generateWorldcupThumbnailFontTest(
            imageUrls,
          );
        if (!thumbnailBuffer) {
          throw new Error('Thumbnail buffer is empty (generated failed)');
        }
        const thumbnailBase64 = `data:image/jpeg;base64,${thumbnailBuffer.toString(
          'base64',
        )}`;
        const thumbnailUpload =
          await this.azureBlobService.uploadFileImageBase64(
            thumbnailBase64,
            false,
            true,
          );

        if (thumbnailUpload) {
          url = thumbnailUpload.url;
          await this.db
            .updateTable('photos')
            .set({ thumbnail_worldcup_id: thumbnailUpload.id })
            .where('id', '=', photoId)
            .execute();
          //console.log(`[PhotoService] 썸네일 생성 성공 (${i + 1}번째 시도)`);
          break; // 성공 시 루프 탈출
        }
      } catch (error) {
        console.error(
          `[PhotoService] 썸네일 생성 실패 (${i + 1}번째 시도):`,
          error,
        );
        if (i === MAX_THUMBNAIL_RETRY - 1) {
          console.error('[PhotoService] Worldcup thumbnail generation failed');
        }
      }
    }
    return url;
  }